use std::borrow::Cow;
use std::env;
use std::ffi::OsStr;
use std::io::{self, Write};
use std::process::Command;

mod quote;
use quote::ShellQuote;

const SCRIPT_HEADER: &str = "\
#!/bin/bash
# This script was generated by the command-script library
set -e
";

#[derive(Debug, Default)]
pub struct CommandScript {
    set_envs: EnvMode,
    set_cwd: EnvMode,
}

impl CommandScript {
    pub fn include_envs(&mut self, mode: EnvMode) -> &mut Self {
        self.set_envs = mode;
        self
    }

    pub fn change_dir(&mut self, mode: EnvMode) -> &mut Self {
        self.set_cwd = mode;
        self
    }

    pub fn output<W: Write>(&self, cmd: &Command, out: &mut W) -> io::Result<()> {
        out.write_all(SCRIPT_HEADER.as_bytes())?;

        match self.set_envs {
            EnvMode::Omit => (),
            EnvMode::ExplicitOnly => {
                write_envs(out, cmd.get_envs())?;
                writeln!(out)?;
            }
            EnvMode::ExplicitAndInherited => {
                write_envs(out, env::vars_os().map(|(k, v)| (k, Some(v))))?;
                write_envs(out, cmd.get_envs())?;
                writeln!(out)?;
            }
        }

        let cmd_explicit_dir =
            || cmd.get_current_dir().map(|p| p.to_str().ok_or_else(invalid_utf8)).transpose();
        let dir: Option<Cow<'_, str>> = match self.set_cwd {
            EnvMode::Omit => None,
            EnvMode::ExplicitOnly => cmd_explicit_dir()?.map(Cow::from),
            EnvMode::ExplicitAndInherited => Some(match cmd_explicit_dir()? {
                Some(dir) => Cow::from(dir),
                None => Cow::from(env::current_dir().map(|path| {
                    path.into_os_string().into_string().map_err(|_| invalid_utf8())
                })??),
            }),
        };
        if let Some(dir) = dir {
            write!(out, "cd {}\n\n", ShellQuote(&dir))?;
        }

        writeln!(out, "__command_script_args=(")?;
        let prog = cmd.get_program().to_str().ok_or_else(invalid_utf8)?;
        writeln!(out, "    {}", ShellQuote(prog))?;

        for arg in cmd.get_args() {
            let arg = arg.to_str().ok_or_else(invalid_utf8)?;
            writeln!(out, "    {}", ShellQuote(arg))?;
        }
        write!(out, ")\n\n")?;

        out.write_all(b"exec \"${__command_script_args[@]}\"\n")?;

        Ok(())
    }
}

fn invalid_utf8() -> io::Error {
    io::Error::new(io::ErrorKind::InvalidData, "A Command argument is not valid UTF-8")
}

fn write_envs<I, K, V, W>(out: &mut W, it: I) -> io::Result<()>
where
    I: IntoIterator<Item = (K, Option<V>)>,
    K: AsRef<OsStr>,
    V: AsRef<OsStr>,
    W: Write,
{
    for (k, v) in it {
        let ks = k.as_ref().to_str().ok_or_else(invalid_utf8)?;
        match v {
            Some(v) => {
                let vs = v.as_ref().to_str().ok_or_else(invalid_utf8)?;
                writeln!(out, "export {}={}", ks, ShellQuote(vs))?;
            }
            None => writeln!(out, "unset {}", ks)?,
        }
    }
    Ok(())
}

/// The output mode for setting environment variables and changing directory in the output script.
#[derive(Debug, Clone, Copy)]
pub enum EnvMode {
    /// Exclude from the script entirely
    Omit,
    /// Only include if explicitly set in the Command
    ExplicitOnly,
    /// Like `ExplicitOnly` but also include env vars and working directory that would be inherited
    /// from the parent (current) process
    ExplicitAndInherited,
}

impl Default for EnvMode {
    #[inline]
    fn default() -> Self {
        EnvMode::Omit
    }
}
